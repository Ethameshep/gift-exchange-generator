<!DOCTYPE html>
<!-- saved from url=(0064)file:///home/ethandev/Documents/Projects/secret-santa/index.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gift Exchange Pairing Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 40px 20px;
            }
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .section {
            margin-bottom: 40px;
        }

        .section-title {
            font-size: 1.3em;
            color: #764ba2;
            margin-bottom: 15px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .input-group {
                flex-direction: column;
            }
        }

        .input-group button {
            flex-shrink: 0;
        }

        input, select {
            flex: 1;
            padding: 12px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s, transform 0.1s;
            font-weight: 600;
            min-width: max-content;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: #764ba2;
        }

        button.secondary:hover {
            background: #633a8a;
        }

        button.danger {
            background: transparent;
            color: #e74c3c;
            padding: 0;
        }

        button.danger:hover {
            color: #c0392b;
        }

        .participants-list {
            margin-top: 15px;
        }

        .participant-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #f8f9fa;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .participant-info {
            flex: 1;
        }

        .participant-name {
            font-weight: 600;
            color: #333;
        }

        .participant-phone {
            font-size: 0.9em;
        }

        .participant-wishlist {
            font-size: 0.9em;
            margin-top: 4px;
        }

        .participant-wishlist a {
            color: #667eea;
            text-decoration: none;
        }

        .participant-wishlist a:hover {
            text-decoration: underline;
        }

        .exclusions-list {
            margin-top: 15px;
        }

        .exclusion-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #fff3cd;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #ffc107;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .exclusion-pair {
            flex: 1;
            display: flex;
            align-items: center;
        }

        .exclusion-separator {
            display: inline-block;
            margin: 0 12px;
            font-size: 1.2em;
            vertical-align: middle;
        }

        .exclusion-separator::before {
            content: '➜';
        }

        .exclusion-receiver {
            font-size: 1.1em;
        }

        .results {
            margin-top: 30px;
            display: none;
        }

        @media (max-width: 768px) {
            .results > div {
                flex-direction: column;
                align-items: normal !important;
            }
        }

        .results.show {
            display: block;
        }

        .pair-item {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pair-info {
            flex: 1;
        }

        .pair-names {
            display: flex;
            align-items: center;
        }

        .pair-giver {
            font-weight: 600;
            color: #667eea;
            font-size: 1.1em;
        }

        .pair-separator {
            display: inline-block;
            margin: 0 12px;
            font-size: 1.2em;
            vertical-align: middle;
        }

        .pair-separator::before {
            content: '➜';
        }

        .pair-receiver {
            font-size: 1.1em;
        }

        .pair-phone {
            font-size: 0.9em;
        }

        .pair-wishlist {
            font-size: 0.9em;
            margin-top: 5px;
            word-break: break-word;
            overflow-wrap: break-word;
        }

        .pair-wishlist a {
            color: #667eea;
            text-decoration: none;
        }

        .pair-wishlist a:hover {
            text-decoration: underline;
        }

        .generate-btn {
            width: 100%;
            padding: 16px;
            font-size: 18px;
            margin-top: 20px;
        }

        .empty-state {
            text-align: center;
            color: #999;
            padding: 20px;
            font-style: italic;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #c33;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Gift Exchange Pairing Generator</h1>

        <div class="section">
            <h2 class="section-title">Add Participants</h2>
            <div class="input-group">
                <input type="text" id="nameInput" placeholder="Name*" maxlength="100">
                <input type="tel" id="phoneInput" placeholder="(XXX) XXX-XXXX" maxlength="20">
                <input type="url" id="wishlistInput" placeholder="Wishlist URL" maxlength="2048">
                <button class="secondary" onclick="addParticipant()">Add</button>
            </div>
            <div id="participantsList" class="participants-list"><div class="empty-state">No participants added yet</div></div>
        </div>

        <div class="section">
            <h2 class="section-title">Exclude Pairs</h2>
            <div class="input-group">
                <select id="excludeGiver">
                    <option value="">Select giver...</option>
                </select>
                <select id="excludeReceiver">
                    <option value="">Select receiver...</option>
                </select>
                <button class="secondary" onclick="addExclusion()">Exclude</button>
            </div>
            <div id="exclusionsList" class="exclusions-list"><div class="empty-state">No exclusions set</div></div>
        </div>

        <button class="generate-btn" onclick="generatePairings()">Generate Pairings</button>

        <div id="errorMessage"></div>

        <div id="results" class="results">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; gap: 20px;">
                <h2 class="section-title" style="margin-bottom: 0; width: 100%;">Generated Pairings</h2>
                <button class="secondary" onclick="exportPairingsToCSV()" id="exportBtn" style="display: none;">Export to CSV</button>
            </div>
            <div id="pairingsList"></div>
        </div>
    </div>

    <script>
        let participants = [];
        let exclusions = [];
        let currentPairings = [];

        // Escape HTML to prevent XSS attacks
        function escapeHtml(text) {
            if (text == null) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Escape HTML attribute values
        function escapeHtmlAttr(text) {
            if (text == null) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#x27;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        function addParticipant() {
            const nameInput = document.getElementById('nameInput');
            const phoneInput = document.getElementById('phoneInput');
            const wishlistInput = document.getElementById('wishlistInput');
            const name = nameInput.value.trim();
            const phone = phoneInput.value.trim();
            const wishlist = wishlistInput.value.trim();

            if (!name) {
                showError('Please enter a name');
                return;
            }

            // Validate input lengths
            if (name.length > 100) {
                showError('Name must be 100 characters or less');
                return;
            }

            if (phone.length > 20) {
                showError('Phone number must be 20 characters or less');
                return;
            }

            if (wishlist && wishlist.length > 2048) {
                showError('Wishlist URL must be 2048 characters or less');
                return;
            }

            if (participants.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                showError('This name is already added');
                return;
            }

            participants.push({ name, phone: phone || 'N/A', wishlist: wishlist || null });
            nameInput.value = '';
            phoneInput.value = '';
            wishlistInput.value = '';
            updateParticipantsList();
            updateExclusionDropdowns();
            clearError();
        }

        function removeParticipant(index) {
            participants.splice(index, 1);
            // Remove exclusions involving this participant
            exclusions = exclusions.filter(ex => 
                ex.giverIndex !== index && ex.receiverIndex !== index
            );
            // Reindex remaining exclusions: decrement indices greater than the removed index
            exclusions = exclusions.map(ex => ({
                giverIndex: ex.giverIndex > index ? ex.giverIndex - 1 : ex.giverIndex,
                receiverIndex: ex.receiverIndex > index ? ex.receiverIndex - 1 : ex.receiverIndex
            }));
            updateParticipantsList();
            updateExclusionDropdowns();
            updateExclusionsList();
        }

        function updateParticipantsList() {
            const list = document.getElementById('participantsList');
            if (participants.length === 0) {
                list.innerHTML = '<div class="empty-state">No participants added yet</div>';
                return;
            }

            list.innerHTML = participants.map((p, index) => `
                <div class="participant-item">
                    <div class="participant-info">
                        <div class="participant-name">${escapeHtml(p.name)}</div>
                    </div>
                    <button class="danger" onclick="removeParticipant(${index})">Remove</button>
                </div>
            `).join('');
        }

        function addExclusion() {
            const giverSelect = document.getElementById('excludeGiver');
            const receiverSelect = document.getElementById('excludeReceiver');
            
            // Check if selections are empty before parsing
            if (giverSelect.value === '' || receiverSelect.value === '') {
                showError('Please select both giver and receiver');
                return;
            }
            
            const giverIndex = parseInt(giverSelect.value);
            const receiverIndex = parseInt(receiverSelect.value);

            // Validate parsed values (check for NaN)
            if (isNaN(giverIndex) || isNaN(receiverIndex)) {
                showError('Please select both giver and receiver');
                return;
            }

            // Validate bounds and non-negative indices
            if (giverIndex < 0 || giverIndex >= participants.length ||
                receiverIndex < 0 || receiverIndex >= participants.length) {
                showError('Invalid participant selection');
                return;
            }

            if (giverIndex === receiverIndex) {
                showError('A person cannot be excluded from themselves');
                return;
            }

            // Check if this exclusion already exists (unidirectional)
            if (exclusions.some(ex => 
                ex.giverIndex === giverIndex && ex.receiverIndex === receiverIndex
            )) {
                showError('This exclusion already exists');
                return;
            }

            exclusions.push({ giverIndex, receiverIndex });
            updateExclusionsList();
            clearError();
        }

        function removeExclusion(index) {
            exclusions.splice(index, 1);
            updateExclusionsList();
        }

        // Cleanup function to remove invalid exclusions (e.g., with out-of-bounds indices)
        function cleanupInvalidExclusions() {
            const initialCount = exclusions.length;
            exclusions = exclusions.filter(ex => 
                ex.giverIndex >= 0 && ex.giverIndex < participants.length &&
                ex.receiverIndex >= 0 && ex.receiverIndex < participants.length
            );
            if (exclusions.length < initialCount) {
                updateExclusionsList();
            }
        }

        function updateExclusionsList() {
            const list = document.getElementById('exclusionsList');
            if (exclusions.length === 0) {
                list.innerHTML = '<div class="empty-state">No exclusions set</div>';
                return;
            }

            list.innerHTML = exclusions.map((ex, index) => {
                // Defensive checks: validate indices before accessing participants array
                const giver = (ex.giverIndex >= 0 && ex.giverIndex < participants.length)
                    ? escapeHtml(participants[ex.giverIndex].name)
                    : '[Invalid]';
                const receiver = (ex.receiverIndex >= 0 && ex.receiverIndex < participants.length)
                    ? escapeHtml(participants[ex.receiverIndex].name)
                    : '[Invalid]';
                return `
                    <div class="exclusion-item">
                        <div class="exclusion-pair">
                            <span class="exclusion-giver">${giver}</span>
                            <span class="exclusion-separator"></span>
                            <span class="exclusion-receiver">${receiver}</span>
                        </div>
                        <button class="danger" onclick="removeExclusion(${index})">Remove</button>
                    </div>
                `;
            }).join('');
        }

        function updateExclusionDropdowns() {
            const giverSelect = document.getElementById('excludeGiver');
            const receiverSelect = document.getElementById('excludeReceiver');

            giverSelect.innerHTML = '<option value="">Select giver...</option>' +
                participants.map((p, i) => `<option value="${i}">${escapeHtml(p.name)}</option>`).join('');

            receiverSelect.innerHTML = '<option value="">Select receiver...</option>' +
                participants.map((p, i) => `<option value="${i}">${escapeHtml(p.name)}</option>`).join('');
        }

        function generatePairings() {
            clearError();

            if (participants.length < 2) {
                showError('Please add at least 2 participants');
                return;
            }

            // Clean up any invalid exclusions before generating pairings
            cleanupInvalidExclusions();

            // Early feasibility check: ensure a solution is possible
            const feasibilityResult = checkPairingFeasibility();
            if (!feasibilityResult.possible) {
                showError(feasibilityResult.message);
                return;
            }

            // Use backtracking algorithm to generate valid pairings
            const pairings = generatePairingBacktrack();

            if (!pairings) {
                showError('Could not generate valid pairings. Try removing some exclusions.');
                return;
            }

            displayPairings(pairings);
        }

        // Early feasibility check: determines if a valid pairing is possible
        // Returns { possible: boolean, message: string }
        function checkPairingFeasibility() {
            // Build exclusion map for faster lookups
            const exclusionMap = new Map();
            exclusions.forEach(ex => {
                // Validate exclusion indices
                if (ex.giverIndex < 0 || ex.giverIndex >= participants.length ||
                    ex.receiverIndex < 0 || ex.receiverIndex >= participants.length) {
                    return; // Skip invalid exclusions
                }
                if (!exclusionMap.has(ex.giverIndex)) {
                    exclusionMap.set(ex.giverIndex, new Set());
                }
                exclusionMap.get(ex.giverIndex).add(ex.receiverIndex);
            });
            
            // Check each giver has at least one valid receiver
            const impossibleGivers = [];
            for (let g = 0; g < participants.length; g++) {
                const excluded = exclusionMap.get(g) || new Set();
                // Valid receivers = all participants - self - excluded
                const validCount = participants.length - 1 - excluded.size;
                
                if (validCount === 0) {
                    impossibleGivers.push(participants[g].name);
                }
            }
            
            if (impossibleGivers.length > 0) {
                const names = impossibleGivers.join(', ');
                const verb = impossibleGivers.length === 1 ? 'has' : 'have';
                return {
                    possible: false,
                    message: `Cannot generate pairings: ${names} ${verb} no valid receivers. Please remove some exclusions.`
                };
            }
            
            return { possible: true, message: '' };
        }

        // Backtracking algorithm for generating valid pairings
        // Guarantees finding a solution if one exists, with no retry limit needed
        function generatePairingBacktrack() {
            // assignment[giverIndex] = receiverIndex: tracks which receiver each giver is assigned to
            const assignment = new Array(participants.length).fill(-1);
            // used[receiverIndex] = true: tracks which receivers have been assigned
            const used = new Array(participants.length).fill(false);
            // receiverToGiver[receiverIndex] = giverIndex: reverse lookup for O(1) mutual pair checking
            const receiverToGiver = new Map();
            
            // Build exclusion map for faster lookups
            const exclusionMap = new Map();
            exclusions.forEach(ex => {
                // Skip invalid exclusions
                if (ex.giverIndex < 0 || ex.giverIndex >= participants.length ||
                    ex.receiverIndex < 0 || ex.receiverIndex >= participants.length) {
                    return;
                }
                if (!exclusionMap.has(ex.giverIndex)) {
                    exclusionMap.set(ex.giverIndex, new Set());
                }
                exclusionMap.get(ex.giverIndex).add(ex.receiverIndex);
            });
            
            // Pre-compute valid receivers for each giver (excluding self and exclusions)
            // This avoids recalculating on every recursive call
            const validReceiversMap = new Map();
            for (let g = 0; g < participants.length; g++) {
                const valid = [];
                const excluded = exclusionMap.get(g) || new Set();
                for (let r = 0; r < participants.length; r++) {
                    if (r === g) continue; // Can't pair with self
                    if (excluded.has(r)) continue; // Check exclusions
                    valid.push(r);
                }
                validReceiversMap.set(g, valid);
            }
            
            /**
             * Checks if assigning receiverIndex to giverIndex would create a mutual pair
             * A mutual pair occurs when: A gives to B AND B gives to A
             * @param {number} giverIndex - The giver being assigned
             * @param {number} receiverIndex - The receiver being assigned to the giver
             * @returns {boolean} - True if this would create a mutual pair
             */
            function wouldCreateMutualPair(giverIndex, receiverIndex) {
                // Check if receiverIndex is already assigned to give to giverIndex
                // If so, assigning giverIndex -> receiverIndex would create: giverIndex -> receiverIndex AND receiverIndex -> giverIndex
                return receiverToGiver.get(receiverIndex) === giverIndex;
            }
            
            function backtrack(giverIndex) {
                // Base case: all givers have been assigned
                if (giverIndex === participants.length) {
                    return true;
                }
                
                // Get pre-computed valid receivers for this giver
                // Filter out already used receivers and check for mutual pairs
                const baseValidReceivers = validReceiversMap.get(giverIndex);
                const validReceivers = [];
                
                for (const receiverIndex of baseValidReceivers) {
                    // Already assigned to another giver
                    if (used[receiverIndex]) continue;
                    
                    // Check if this would create a mutual pair (A->B and B->A)
                    if (wouldCreateMutualPair(giverIndex, receiverIndex)) continue;
                    
                    validReceivers.push(receiverIndex);
                }
                
                // If no valid receivers, backtrack
                if (validReceivers.length === 0) {
                    return false;
                }
                
                // Shuffle valid receivers for randomness
                for (let i = validReceivers.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [validReceivers[i], validReceivers[j]] = [validReceivers[j], validReceivers[i]];
                }
                
                // Try each valid receiver
                for (const receiverIndex of validReceivers) {
                    // Assign this receiver to the giver
                    assignment[giverIndex] = receiverIndex;
                    used[receiverIndex] = true;
                    receiverToGiver.set(receiverIndex, giverIndex);
                    
                    // Recursively try to assign remaining givers
                    if (backtrack(giverIndex + 1)) {
                        return true;
                    }
                    
                    // Backtrack: this assignment didn't work, try next
                    assignment[giverIndex] = -1;
                    used[receiverIndex] = false;
                    receiverToGiver.delete(receiverIndex);
                }
                
                // No valid assignment found for this giver
                return false;
            }
            
            // Start backtracking from the first giver
            if (!backtrack(0)) {
                return null; // No solution exists
            }
            
            // Convert assignment array to pairing objects
            return assignment.map((receiverIndex, giverIndex) => ({
                giver: participants[giverIndex],
                receiver: participants[receiverIndex]
            }));
        }

        function displayPairings(pairings) {
            const resultsDiv = document.getElementById('results');
            const pairingsList = document.getElementById('pairingsList');
            const exportBtn = document.getElementById('exportBtn');

            // Store pairings for export
            currentPairings = pairings;

            pairingsList.innerHTML = pairings.map(pair => {
                const giverName = escapeHtml(pair.giver.name);
                const receiverName = escapeHtml(pair.receiver.name);
                const phone = pair.receiver.phone && pair.receiver.phone !== 'N/A' 
                    ? `<div class="pair-phone">Phone: ${escapeHtml(pair.receiver.phone)}</div>` 
                    : '';
                const wishlist = pair.receiver.wishlist 
                    ? `<div class="pair-wishlist">Wishlist: <a href="${escapeHtmlAttr(pair.receiver.wishlist)}" target="_blank" rel="noopener noreferrer">${escapeHtml(pair.receiver.wishlist)}</a></div>` 
                    : '';
                return `
                <div class="pair-item">
                    <div class="pair-info">
                        <div class="pair-names">
                            <span class="pair-giver">${giverName}</span>
                            <span class="pair-separator"></span>
                            <span class="pair-receiver">${receiverName}</span>
                        </div>
                        ${phone}
                        ${wishlist}
                    </div>
                </div>
            `;
            }).join('');

            resultsDiv.classList.add('show');
            exportBtn.style.display = 'block';
        }

        function exportPairingsToCSV() {
            if (currentPairings.length === 0) {
                showError('No pairings to export');
                return;
            }

            // CSV headers
            const headers = ['Giver', 'Receiver', 'Receiver Phone', 'Receiver Wishlist'];
            
            // CSV rows
            const rows = currentPairings.map(pair => {
                const giver = `"${pair.giver.name.replace(/"/g, '""')}"`;
                const receiver = `"${pair.receiver.name.replace(/"/g, '""')}"`;
                const phone = `"${pair.receiver.phone.replace(/"/g, '""')}"`;
                const wishlist = pair.receiver.wishlist ? `"${pair.receiver.wishlist.replace(/"/g, '""')}"` : '""';
                return [giver, receiver, phone, wishlist].join(',');
            });

            // Combine headers and rows
            const csvContent = [headers.join(','), ...rows].join('\n');

            // Create blob and download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', `gift-exchange-pairings-${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Revoke the object URL to prevent memory leaks
            // Use setTimeout to ensure the download has started before revoking
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = `<div class="error">${message}</div>`;
        }

        function clearError() {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = '';
        }

        function formatPhoneNumber(value) {
            // Remove all non-digit characters
            let digits = value.replace(/\D/g, '');
            
            // Remove leading 1 if it's the country code (US) - handle both 10 and 11 digit cases
            // If we have 11 digits and first is 1, remove it (country code)
            if (digits.length >= 11 && digits[0] === '1') {
                digits = digits.substring(1);
            }
            // Also handle case where someone types 1 first but we want to allow it if followed by valid area code
            // For simplicity, if digits start with 1 and total is 11, treat as country code
            // This is safe since US area codes cannot start with 0 or 1
            
            // Limit to 10 digits
            digits = digits.substring(0, 10);
            
            // Format based on length
            if (digits.length === 0) {
                return '';
            } else if (digits.length <= 3) {
                return `(${digits}`;
            } else if (digits.length <= 6) {
                return `(${digits.substring(0, 3)}) ${digits.substring(3)}`;
            } else {
                return `(${digits.substring(0, 3)}) ${digits.substring(3, 6)}-${digits.substring(6)}`;
            }
        }

        function capitalizeNameInput(value) {
            if (!value) return '';
            // Split by spaces and capitalize first letter of each word
            return value.split(' ').map(word => {
                if (word.length === 0) return word;
                return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
            }).join(' ');
        }

        function handleNameInput(e) {
            const input = e.target;
            const cursorPosition = input.selectionStart;
            const oldValue = input.value;
            const oldLength = oldValue.length;
            
            // Get the capitalized value
            const newValue = capitalizeNameInput(input.value);
            
            // Since capitalization doesn't change length, cursor position stays the same
            // Only adjust if we're at the end and text was added
            let newCursorPosition = cursorPosition;
            if (cursorPosition === oldLength && newValue.length >= oldLength) {
                newCursorPosition = newValue.length;
            }
            
            input.value = newValue;
            // Use setTimeout to ensure the cursor position is set after the value is updated
            setTimeout(() => {
                input.setSelectionRange(newCursorPosition, newCursorPosition);
            }, 0);
        }

        function handlePhoneInput(e) {
            const input = e.target;
            const cursorPosition = input.selectionStart;
            const oldValue = input.value;
            const oldLength = oldValue.length;
            
            // Count digits before cursor in old value
            const digitsBeforeCursor = (oldValue.substring(0, cursorPosition).match(/\d/g) || []).length;
            
            // Get the formatted value
            const newValue = formatPhoneNumber(input.value);
            
            // Find the position in new value that corresponds to the same number of digits
            let newCursorPosition = newValue.length;
            let digitCount = 0;
            
            for (let i = 0; i < newValue.length; i++) {
                if (/\d/.test(newValue[i])) {
                    if (digitCount === digitsBeforeCursor) {
                        // Position cursor after this digit
                        newCursorPosition = i + 1;
                        break;
                    }
                    digitCount++;
                }
            }
            
            // If we were at the end and typing, keep cursor at end
            if (cursorPosition === oldLength && newValue.length > oldValue.length) {
                newCursorPosition = newValue.length;
            }
            
            input.value = newValue;
            // Use setTimeout to ensure the cursor position is set after the value is updated
            setTimeout(() => {
                input.setSelectionRange(newCursorPosition, newCursorPosition);
            }, 0);
        }

        // Auto-capitalize name input and handle Enter key
        const nameInput = document.getElementById('nameInput');
        nameInput.addEventListener('input', handleNameInput);
        nameInput.addEventListener('paste', function(e) {
            // Allow paste to complete, then format
            setTimeout(() => {
                handleNameInput(e);
            }, 0);
        });
        nameInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addParticipant();
            }
        });

        const phoneInput = document.getElementById('phoneInput');
        phoneInput.addEventListener('input', handlePhoneInput);
        phoneInput.addEventListener('paste', function(e) {
            // Allow paste to complete, then format
            setTimeout(() => {
                handlePhoneInput(e);
            }, 0);
        });
        phoneInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addParticipant();
            }
        });

        document.getElementById('wishlistInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addParticipant();
            }
        });

        // Initialize
        updateParticipantsList();
        updateExclusionsList();
    </script>


</body></html>
